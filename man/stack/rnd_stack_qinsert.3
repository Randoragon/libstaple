.TH RND_STACK_QINSERT 3 DATE "librnd-VERSION"
.SH NAME
rnd_stack_qinsert, rnd_stack_qinsertc, rnd_stack_qinserts,
rnd_stack_qinserti, rnd_stack_qinsertl, rnd_stack_qinsertsc,
rnd_stack_qinsertuc, rnd_stack_qinsertus, rnd_stack_qinsertui,
rnd_stack_qinsertul, rnd_stack_qinsertf, rnd_stack_qinsertd,
rnd_stack_qinsertld \- quickly insert an element at any position of a stack
.SH SYNOPSIS
.ad l
#include <rnd.h>
.sp
int
.BR rnd_stack_qinsert "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
const void
.RI * elem )
.br
int
.BR rnd_stack_qinsertc "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
char
.IR elem )
.br
int
.BR rnd_stack_qinserts "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
short
.IR elem )
.br
int
.BR rnd_stack_qinserti "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
int
.IR elem )
.br
int
.BR rnd_stack_qinsertl "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
long
.IR elem )
.br
int
.BR rnd_stack_qinsertsc "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
signed char
.IR elem )
.br
int
.BR rnd_stack_qinsertuc "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned char
.IR elem )
.br
int
.BR rnd_stack_qinsertus "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned short
.IR elem )
.br
int
.BR rnd_stack_qinsertui "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned int
.IR elem )
.br
int
.BR rnd_stack_qinsertul "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
unsigned long
.IR elem )
.br
int
.BR rnd_stack_qinsertf "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
float
.IR elem )
.br
int
.BR rnd_stack_qinsertd "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
double
.IR elem )
.br
int
.BR rnd_stack_qinsertld "(struct rnd_stack"
.RI * stack ,
size_t
.IR idx ,
long double
.IR elem )
.sp
Link with \fI-lrnd\fP.
.ad
.SH DESCRIPTION
See
.BR rnd_stack_insert (3).
.P
The functions in the
.BR rnd_stack_qinsert ()
family operate in constant time, which is achievable by changing the order of
the elements upon insertion.
.SH EXAMPLES
To explain how the
.BR rnd_stack_insert ()
and
.BR rnd_stack_qinsert ()
families differ, consider the following initial stack (elements listed
from bottom to top):
.IP
.B 1 2 3 4 _ _ _
.P
Now, let us investigate what happens when we try to insert the number
.B 5
at position
.IR 2 .
.P
The functions in the
.BR rnd_stack_insert ()
family would move
.BR 3 " and " 4
upwards, and insert
.B 5
without altering the order:
.IP (1)
.B 1 2 _ 3 4 _ _
.br
\h'6n'^ ^
.IP (2)
.B 1 2 5 3 4 _ _
.br
\h'4n'^
.P
On the contrary, the functions in the
.BR rnd_stack_qinsert ()
family achieve the goal faster by moving the element "in the way" (in this case
.BR 3 )
to the top of the stack:
.IP (1)
.B 1 2 _ 4 3 _ _
.br
\h'8n'^
.IP (2)
.B 1 2 5 4 3 _ _
.br
\h'4n'^
.P
The second approach guarantees constant time, but does not preserve the order of
the elements.
.SH SEE ALSO
.ad l
.BR librnd (7),
.BR rnd_stack (7),
.BR rnd_stack_create (3),
.BR rnd_stack_destroy (3),
.BR rnd_stack_clear (3),
.BR rnd_stack_copy (3),
.BR rnd_stack_foreach (3),
.BR rnd_stack_push (3),
.BR rnd_stack_insert (3),
.BR rnd_stack_peek (3),
.BR rnd_stack_pop (3),
.BR rnd_stack_remove (3),
.BR rnd_stack_qremove (3),
.BR rnd_stack_get (3),
.BR rnd_stack_set (3),
.BR rnd_stack_print (3)

